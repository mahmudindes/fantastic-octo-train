// Package rapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package rapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

type contextKey string

const (
	BearerAuthScopes contextKey = "BearerAuth.Scopes"
)

// Base0 defines model for Base0.
type Base0 struct {
	CreatedAt time.Time  `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`
}

// Base1 defines model for Base1.
type Base1 struct {
	RID string `json:"rid"`
}

// Error defines model for Error.
type Error struct {
	Message    string `json:"message"`
	StatusCode int    `json:"statusCode"`
}

// Link defines model for Link.
type Link struct {
	Code              string        `json:"code"`
	CreatedAt         time.Time     `json:"createdAt"`
	PasswordProtected bool          `json:"passwordProtected"`
	Rules             *[]LinkRule   `json:"rules,omitempty"`
	Targets           *[]LinkTarget `json:"targets,omitempty"`
	UpdatedAt         *time.Time    `json:"updatedAt"`
	UserUsername      *string       `json:"userUsername"`
}

// LinkRule defines model for LinkRule.
type LinkRule struct {
	CreatedAt    time.Time  `json:"createdAt"`
	IPAddresses  *[]string  `json:"ipAddresses"`
	LanguageTags *[]string  `json:"languageTags"`
	Origins      *[]string  `json:"origins"`
	RID          string     `json:"rid"`
	UpdatedAt    *time.Time `json:"updatedAt"`
}

// LinkTarget defines model for LinkTarget.
type LinkTarget struct {
	CreatedAt      time.Time  `json:"createdAt"`
	HREF           string     `json:"href"`
	HREFRaw        string     `json:"hrefRaw"`
	RID            string     `json:"rid"`
	RuleRID        *string    `json:"ruleRID"`
	UpdatedAt      *time.Time `json:"updatedAt"`
	URLDomain      *string    `json:"urlDomain"`
	URLDomainRaw   *string    `json:"urlDomainRaw"`
	URLFragment    *string    `json:"urlFragment"`
	URLFragmentRaw *string    `json:"urlFragmentRaw"`
	URLPath        *string    `json:"urlPath"`
	URLPathRaw     *string    `json:"urlPathRaw"`
	URLScheme      *string    `json:"urlScheme"`
	URLSchemeRaw   *string    `json:"urlSchemeRaw"`
}

// NewLink defines model for NewLink.
type NewLink struct {
	Code         *string `form:"code" json:"code"`
	Password     *string `form:"password" json:"password"`
	UserUsername *string `form:"userUsername" json:"userUsername"`
}

// NewLinkRule defines model for NewLinkRule.
type NewLinkRule struct {
	IPAddresses  *[]string `form:"ipAddresses" json:"ipAddresses"`
	LanguageTags *[]string `form:"languageTags" json:"languageTags"`
	Origins      *[]string `form:"origins" json:"origins"`
}

// NewLinkTarget defines model for NewLinkTarget.
type NewLinkTarget struct {
	HREF        *string `form:"href" json:"href"`
	RuleRID     *string `form:"ruleRID" json:"ruleRID"`
	URLDomain   *string `form:"urlDomain" json:"urlDomain"`
	URLFragment *string `form:"urlFragment" json:"urlFragment"`
	URLPath     *string `form:"urlPath" json:"urlPath"`
	URLScheme   *string `form:"urlScheme" json:"urlScheme"`
}

// NewUser defines model for NewUser.
type NewUser struct {
	AuthIDToken      *string `form:"authIDToken" json:"authIDToken"`
	AuthIDTokenNonce *string `form:"authIDTokenNonce" json:"authIDTokenNonce"`
	AuthSubject      *string `form:"authSubject" json:"authSubject"`
	Username         string  `form:"username" json:"username"`
}

// SetLink defines model for SetLink.
type SetLink struct {
	Code         *string  `form:"code" json:"code"`
	Password     *string  `form:"password" json:"password"`
	SetNull      []string `form:"setNull,omitempty" json:"setNull,omitempty"`
	UserUsername *string  `form:"userUsername" json:"userUsername"`
}

// SetLinkRule defines model for SetLinkRule.
type SetLinkRule struct {
	IPAddresses  *[]string `form:"ipAddresses" json:"ipAddresses"`
	LanguageTags *[]string `form:"languageTags" json:"languageTags"`
	Origins      *[]string `form:"origins" json:"origins"`
	SetNull      []string  `form:"setNull,omitempty" json:"setNull,omitempty"`
}

// SetLinkTarget defines model for SetLinkTarget.
type SetLinkTarget struct {
	HREF        *string  `form:"href" json:"href"`
	RuleRID     *string  `form:"ruleRID" json:"ruleRID"`
	SetNull     []string `form:"setNull,omitempty" json:"setNull,omitempty"`
	URLDomain   *string  `form:"urlDomain" json:"urlDomain"`
	URLFragment *string  `form:"urlFragment" json:"urlFragment"`
	URLPath     *string  `form:"urlPath" json:"urlPath"`
	URLScheme   *string  `form:"urlScheme" json:"urlScheme"`
}

// SetUser defines model for SetUser.
type SetUser struct {
	AuthSubject *string  `form:"authSubject" json:"authSubject"`
	SetNull     []string `form:"setNull,omitempty" json:"setNull,omitempty"`
	Username    *string  `form:"username" json:"username"`
}

// User defines model for User.
type User struct {
	AuthSubject *string    `json:"authSubject"`
	CreatedAt   time.Time  `json:"createdAt"`
	UpdatedAt   *time.Time `json:"updatedAt"`
	Username    string     `json:"username"`
}

// Default defines model for Default.
type Default = Error

// ListLinkParams defines parameters for ListLink.
type ListLinkParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order of results.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`

	// Code Filter by link code.
	Code *[]string `form:"code,omitempty" json:"code,omitempty"`

	// UserUsername Filter by link user username.
	UserUsername *[]string `form:"user_username,omitempty" json:"user_username,omitempty"`
}

// ListLinkRuleParams defines parameters for ListLinkRule.
type ListLinkRuleParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order of results.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`
}

// ListLinkTargetParams defines parameters for ListLinkTarget.
type ListLinkTargetParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order of results.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`
}

// ListUserParams defines parameters for ListUser.
type ListUserParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Order of results.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`

	// Username Filter by user username.
	Username *[]string `form:"username,omitempty" json:"username,omitempty"`
}

// AddLinkJSONRequestBody defines body for AddLink for application/json ContentType.
type AddLinkJSONRequestBody = NewLink

// AddLinkFormdataRequestBody defines body for AddLink for application/x-www-form-urlencoded ContentType.
type AddLinkFormdataRequestBody = NewLink

// UpdateLinkJSONRequestBody defines body for UpdateLink for application/json ContentType.
type UpdateLinkJSONRequestBody = SetLink

// UpdateLinkFormdataRequestBody defines body for UpdateLink for application/x-www-form-urlencoded ContentType.
type UpdateLinkFormdataRequestBody = SetLink

// AddLinkRuleJSONRequestBody defines body for AddLinkRule for application/json ContentType.
type AddLinkRuleJSONRequestBody = NewLinkRule

// AddLinkRuleFormdataRequestBody defines body for AddLinkRule for application/x-www-form-urlencoded ContentType.
type AddLinkRuleFormdataRequestBody = NewLinkRule

// UpdateLinkRuleJSONRequestBody defines body for UpdateLinkRule for application/json ContentType.
type UpdateLinkRuleJSONRequestBody = SetLinkRule

// UpdateLinkRuleFormdataRequestBody defines body for UpdateLinkRule for application/x-www-form-urlencoded ContentType.
type UpdateLinkRuleFormdataRequestBody = SetLinkRule

// AddLinkTargetJSONRequestBody defines body for AddLinkTarget for application/json ContentType.
type AddLinkTargetJSONRequestBody = NewLinkTarget

// AddLinkTargetFormdataRequestBody defines body for AddLinkTarget for application/x-www-form-urlencoded ContentType.
type AddLinkTargetFormdataRequestBody = NewLinkTarget

// UpdateLinkTargetJSONRequestBody defines body for UpdateLinkTarget for application/json ContentType.
type UpdateLinkTargetJSONRequestBody = SetLinkTarget

// UpdateLinkTargetFormdataRequestBody defines body for UpdateLinkTarget for application/x-www-form-urlencoded ContentType.
type UpdateLinkTargetFormdataRequestBody = SetLinkTarget

// AddUserJSONRequestBody defines body for AddUser for application/json ContentType.
type AddUserJSONRequestBody = NewUser

// AddUserFormdataRequestBody defines body for AddUser for application/x-www-form-urlencoded ContentType.
type AddUserFormdataRequestBody = NewUser

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = SetUser

// UpdateUserFormdataRequestBody defines body for UpdateUser for application/x-www-form-urlencoded ContentType.
type UpdateUserFormdataRequestBody = SetUser

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List link.
	// (GET /links)
	ListLink(w http.ResponseWriter, r *http.Request, params ListLinkParams)
	// Add link.
	// (POST /links)
	AddLink(w http.ResponseWriter, r *http.Request)
	// Delete link.
	// (DELETE /links/{code})
	DeleteLink(w http.ResponseWriter, r *http.Request, code string)
	// Get link.
	// (GET /links/{code})
	GetLink(w http.ResponseWriter, r *http.Request, code string)
	// Update link.
	// (PATCH /links/{code})
	UpdateLink(w http.ResponseWriter, r *http.Request, code string)
	// List link rule.
	// (GET /links/{code}/rules)
	ListLinkRule(w http.ResponseWriter, r *http.Request, code string, params ListLinkRuleParams)
	// Add link rule.
	// (POST /links/{code}/rules)
	AddLinkRule(w http.ResponseWriter, r *http.Request, code string)
	// Delete link rule.
	// (DELETE /links/{code}/rules/{rid})
	DeleteLinkRule(w http.ResponseWriter, r *http.Request, code string, rid string)
	// Get link rule.
	// (GET /links/{code}/rules/{rid})
	GetLinkRule(w http.ResponseWriter, r *http.Request, code string, rid string)
	// Update link rule.
	// (PATCH /links/{code}/rules/{rid})
	UpdateLinkRule(w http.ResponseWriter, r *http.Request, code string, rid string)
	// List link target.
	// (GET /links/{code}/targets)
	ListLinkTarget(w http.ResponseWriter, r *http.Request, code string, params ListLinkTargetParams)
	// Add link target.
	// (POST /links/{code}/targets)
	AddLinkTarget(w http.ResponseWriter, r *http.Request, code string)
	// Delete link target.
	// (DELETE /links/{code}/targets/{rid})
	DeleteLinkTarget(w http.ResponseWriter, r *http.Request, code string, rid string)
	// Get link target.
	// (GET /links/{code}/targets/{rid})
	GetLinkTarget(w http.ResponseWriter, r *http.Request, code string, rid string)
	// Update link target.
	// (PATCH /links/{code}/targets/{rid})
	UpdateLinkTarget(w http.ResponseWriter, r *http.Request, code string, rid string)
	// Get current user.
	// (GET /me)
	GetCurrentUser(w http.ResponseWriter, r *http.Request)
	// List user.
	// (GET /users)
	ListUser(w http.ResponseWriter, r *http.Request, params ListUserParams)
	// Add user.
	// (POST /users)
	AddUser(w http.ResponseWriter, r *http.Request)
	// Delete user.
	// (DELETE /users/{username})
	DeleteUser(w http.ResponseWriter, r *http.Request, username string)
	// Get user.
	// (GET /users/{username})
	GetUser(w http.ResponseWriter, r *http.Request, username string)
	// Update user.
	// (PATCH /users/{username})
	UpdateUser(w http.ResponseWriter, r *http.Request, username string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List link.
// (GET /links)
func (_ Unimplemented) ListLink(w http.ResponseWriter, r *http.Request, params ListLinkParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add link.
// (POST /links)
func (_ Unimplemented) AddLink(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete link.
// (DELETE /links/{code})
func (_ Unimplemented) DeleteLink(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get link.
// (GET /links/{code})
func (_ Unimplemented) GetLink(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update link.
// (PATCH /links/{code})
func (_ Unimplemented) UpdateLink(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List link rule.
// (GET /links/{code}/rules)
func (_ Unimplemented) ListLinkRule(w http.ResponseWriter, r *http.Request, code string, params ListLinkRuleParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add link rule.
// (POST /links/{code}/rules)
func (_ Unimplemented) AddLinkRule(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete link rule.
// (DELETE /links/{code}/rules/{rid})
func (_ Unimplemented) DeleteLinkRule(w http.ResponseWriter, r *http.Request, code string, rid string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get link rule.
// (GET /links/{code}/rules/{rid})
func (_ Unimplemented) GetLinkRule(w http.ResponseWriter, r *http.Request, code string, rid string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update link rule.
// (PATCH /links/{code}/rules/{rid})
func (_ Unimplemented) UpdateLinkRule(w http.ResponseWriter, r *http.Request, code string, rid string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List link target.
// (GET /links/{code}/targets)
func (_ Unimplemented) ListLinkTarget(w http.ResponseWriter, r *http.Request, code string, params ListLinkTargetParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add link target.
// (POST /links/{code}/targets)
func (_ Unimplemented) AddLinkTarget(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete link target.
// (DELETE /links/{code}/targets/{rid})
func (_ Unimplemented) DeleteLinkTarget(w http.ResponseWriter, r *http.Request, code string, rid string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get link target.
// (GET /links/{code}/targets/{rid})
func (_ Unimplemented) GetLinkTarget(w http.ResponseWriter, r *http.Request, code string, rid string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update link target.
// (PATCH /links/{code}/targets/{rid})
func (_ Unimplemented) UpdateLinkTarget(w http.ResponseWriter, r *http.Request, code string, rid string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get current user.
// (GET /me)
func (_ Unimplemented) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List user.
// (GET /users)
func (_ Unimplemented) ListUser(w http.ResponseWriter, r *http.Request, params ListUserParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add user.
// (POST /users)
func (_ Unimplemented) AddUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete user.
// (DELETE /users/{username})
func (_ Unimplemented) DeleteUser(w http.ResponseWriter, r *http.Request, username string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get user.
// (GET /users/{username})
func (_ Unimplemented) GetUser(w http.ResponseWriter, r *http.Request, username string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user.
// (PATCH /users/{username})
func (_ Unimplemented) UpdateUser(w http.ResponseWriter, r *http.Request, username string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListLink operation middleware
func (siw *ServerInterfaceWrapper) ListLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLinkParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", r.URL.Query(), &params.Code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Optional query parameter "user_username" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_username", r.URL.Query(), &params.UserUsername)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_username", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListLink(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddLink operation middleware
func (siw *ServerInterfaceWrapper) AddLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddLink(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteLink operation middleware
func (siw *ServerInterfaceWrapper) DeleteLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteLink(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLink operation middleware
func (siw *ServerInterfaceWrapper) GetLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLink(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateLink operation middleware
func (siw *ServerInterfaceWrapper) UpdateLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateLink(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListLinkRule operation middleware
func (siw *ServerInterfaceWrapper) ListLinkRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLinkRuleParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListLinkRule(w, r, code, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddLinkRule operation middleware
func (siw *ServerInterfaceWrapper) AddLinkRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddLinkRule(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteLinkRule operation middleware
func (siw *ServerInterfaceWrapper) DeleteLinkRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "rid" -------------
	var rid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "rid", runtime.ParamLocationPath, chi.URLParam(r, "rid"), &rid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteLinkRule(w, r, code, rid)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLinkRule operation middleware
func (siw *ServerInterfaceWrapper) GetLinkRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "rid" -------------
	var rid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "rid", runtime.ParamLocationPath, chi.URLParam(r, "rid"), &rid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLinkRule(w, r, code, rid)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateLinkRule operation middleware
func (siw *ServerInterfaceWrapper) UpdateLinkRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "rid" -------------
	var rid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "rid", runtime.ParamLocationPath, chi.URLParam(r, "rid"), &rid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateLinkRule(w, r, code, rid)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListLinkTarget operation middleware
func (siw *ServerInterfaceWrapper) ListLinkTarget(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLinkTargetParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListLinkTarget(w, r, code, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddLinkTarget operation middleware
func (siw *ServerInterfaceWrapper) AddLinkTarget(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddLinkTarget(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteLinkTarget operation middleware
func (siw *ServerInterfaceWrapper) DeleteLinkTarget(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "rid" -------------
	var rid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "rid", runtime.ParamLocationPath, chi.URLParam(r, "rid"), &rid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteLinkTarget(w, r, code, rid)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLinkTarget operation middleware
func (siw *ServerInterfaceWrapper) GetLinkTarget(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "rid" -------------
	var rid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "rid", runtime.ParamLocationPath, chi.URLParam(r, "rid"), &rid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLinkTarget(w, r, code, rid)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateLinkTarget operation middleware
func (siw *ServerInterfaceWrapper) UpdateLinkTarget(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "rid" -------------
	var rid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "rid", runtime.ParamLocationPath, chi.URLParam(r, "rid"), &rid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rid", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateLinkTarget(w, r, code, rid)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUser(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListUser operation middleware
func (siw *ServerInterfaceWrapper) ListUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUser(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddUser operation middleware
func (siw *ServerInterfaceWrapper) AddUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddUser(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, chi.URLParam(r, "username"), &username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, username)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, chi.URLParam(r, "username"), &username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, username)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, chi.URLParam(r, "username"), &username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, username)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links", wrapper.ListLink)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/links", wrapper.AddLink)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/links/{code}", wrapper.DeleteLink)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links/{code}", wrapper.GetLink)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/links/{code}", wrapper.UpdateLink)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links/{code}/rules", wrapper.ListLinkRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/links/{code}/rules", wrapper.AddLinkRule)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/links/{code}/rules/{rid}", wrapper.DeleteLinkRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links/{code}/rules/{rid}", wrapper.GetLinkRule)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/links/{code}/rules/{rid}", wrapper.UpdateLinkRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links/{code}/targets", wrapper.ListLinkTarget)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/links/{code}/targets", wrapper.AddLinkTarget)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/links/{code}/targets/{rid}", wrapper.DeleteLinkTarget)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links/{code}/targets/{rid}", wrapper.GetLinkTarget)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/links/{code}/targets/{rid}", wrapper.UpdateLinkTarget)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/me", wrapper.GetCurrentUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.ListUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users", wrapper.AddUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{username}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{username}", wrapper.GetUser)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/users/{username}", wrapper.UpdateUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/wcAAP//4j01YINRAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
